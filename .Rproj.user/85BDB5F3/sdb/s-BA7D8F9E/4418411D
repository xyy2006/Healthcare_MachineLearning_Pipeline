{
    "contents" : "#!/bin/bash\n# Content: A function can run random forest with simultaneous selection method on provided arguments, which at least should include data, knowledge-driven predictors and data-driven predictors.\n# Note: \n#\t\tThe data should have response_variable (just one) be either continuous or categorical, .\n# Author: Yang Yang\n# Date:\"Tue Jul  1 08:57:26 2014\"\n# Usage: To be loaded by main program:ModelComputation_workbench_setup.r \n#######################################################################################\n#--------------------#\n# load some prerequisite libraries\nsuppressPackageStartupMessages( require(randomForestSRC) )\t# the essence\nsuppressPackageStartupMessages( require(survival) )\t# the essence\n#-----#\n# a subfunction to settup the parallel scheme within rfsrc package.\n# called later in RSForest, however, it will be setup in .GlobalEnv.\nsetRSForest_cores <- function(rf.cores_openMP = detectCores()-1, mc.cores_fork = detectCores()-1) {\n\toptions(rf.cores=rf.cores_openMP, mc.cores=mc.cores_fork )\t# setting up OpenMP cores.\n\tinvisible()\n}\n#--------------------#\n# args(rfsrc)\n# function (formula, data, ntree = 1000, bootstrap = c(\"by.root\",\n    # \"by.node\", \"none\"), mtry = NULL, nodesize = NULL, nodedepth = NULL,\n    # splitrule = NULL, nsplit = 0, split.null = FALSE, importance = c(\"permute\",\n        # \"random\", \"permute.ensemble\", \"random.ensemble\", \"none\"),\n    # na.action = c(\"na.omit\", \"na.impute\", \"na.random\"), nimpute = 1,\n    # ntime, cause, xvar.wt = NULL, proximity = FALSE, forest = TRUE,\n    # var.used = c(FALSE, \"all.trees\", \"by.tree\"), split.depth = c(FALSE,\n        # \"all.trees\", \"by.tree\"), seed = NULL, do.trace = FALSE,\n    # membership = TRUE, statistics = FALSE, ...)\n\n\n#--------------------#\nRandomForest <- function(data = data_input,response_variables = response_variables_vec, knowledge_driven_factors = knowledge_driven_factors_vec, data_driven_factors = data_driven_factors_vec, factors_annotation_table = factors_all,.seed=123,plotNameEssence = sprintf(\"RandomForest_plot_at_%s\",nowTimeToString()), add_varMarginalEffectPartialPlot = FALSE ){\n\t# browser()\n\t# response_variables <- response_variables_vec <- c(\"LOS.x\",\"died\")\t# debugging usage\n\t# data = data[1:1000]\t# reduced set, debugging usage.\n\t#\n\t\n\t#----match call for 'setRSForest_cores'------#\n\tfunction_index_in_calls <- grep(sprintf(\":%s$\",\"setRSForest_cores\"), names(calls_pm),perl=T )\t# hard match\n\tstopifnot(length(function_index_in_calls) <= 1) # must only have one match or no match for a function within module.\n\tif (length(function_index_in_calls)) {\n\t\teval.quoted(calls_pm[[function_index_in_calls]])\t# need plyr.\n\t\t# # or use\n\t\t# eval(calls_pm[[function_index_in_calls]][[1]])\t# due to named calls\n\t} else {\t# if no configuration found, use this:\n\t\tsetRSForest_cores(rf.cores_openMP = detectCores()-1, mc.cores_fork = detectCores()-1)\n\t}\n\t\n\t#-----------#\n\toriginalN <- nrow(data)\t# record the data raw size\n\tdata <- na.omit( data[,c(response_variables,knowledge_driven_factors,data_driven_factors),with=F] )\n\t\t\t\t\t\t\t\t\t\t# get a perfect data in sense, otherwise stepAIC will report error due to different sample size each time when it deals with a variable.\n\t\t\t\t\t\t\t\t\t\t# alternative is to impute for those\n\t\t\t\t\t\t\t\t\t\t# variables having NAs.\n\tmessage(\"The final perfect sample size (records) before 'predictive model' module running is:\",nrow(data))\n\tmessage(\"sample size (records) loss is:\",originalN - nrow(data))\n\tstopifnot( length(response_variables) == 1 )\t# limit for 1 response variable.\n\tinvisible( na.fail(data) )\t# check for data integrity.\n\t#----------#\n\t#----------#\n\t# need to remove those variables having only one level due to a few samples removal above.\n\tflag_uniform_info_variable <- data[,sapply(.SD,function(x)length(table(x))),.SDcols=colnames(data) ] == 1\n\tstopifnot( length(flag_uniform_info_variable) == ncol(data) )\n\tdata <- data[,colnames(data)[!flag_uniform_info_variable],with=F]\t# remove those factors only have one level.\n\tdata_driven_factors <- data_driven_factors[!is.na( match(data_driven_factors, colnames(data) ) )]\n\tknowledge_driven_factors <- knowledge_driven_factors[!is.na( match(knowledge_driven_factors, colnames(data) ) )]\n\t# cat(data_driven_factors)\t# for debugging.\n\tmessage(\"We have \", length(data_driven_factors), \" data-driven variables left after QC and before 'predictive model'\")\n\tmessage(\"We have \", length(knowledge_driven_factors), \" knowledge-driven variables left after QC and before 'predictive model'\")\n\n\t\n\t# result <- enet(x = data.matrix(data[,c(knowledge_driven_factors,data_driven_factors),with=F] ), y = data.matrix(data[,response_variables,with=F]),lambda=0.5,trace=T)\t# 1 for lasso, 0 for ridge.\n\t#\n\t#---a subfunc to manipulate the covariate format---#\n\t# to correspond to continuous or categorical variables definition.\t\n\t# assignCovariateFormat <- function(variableName, dataType=factors_annotation_table[variableName,dataType][,dataType]){\n\t\t# switch(dataType,\n\t\t\t\t# categorical = sprintf(\"as.factor(%s)\",variableName),\n\t\t\t\t# continuous = variableName\n\t\t# )\n\t# }\n\t#---#\n\t# this variant version change the data itself in place.\n\tassignCovariateFormat_onData_version <- function(variableName){\n\t\tdata_type = factors_annotation_table[variableName,dataType] %>% unlist\t# involve the data.table and pipeR syntax.\t\t\n\t\tswitch(data_type,\n\t\t\t\tcategorical = { \n\t\t\t\t\ttemp <- unlist(data[,variableName,with=F]);\n\t\t\t\t\tdata[,variableName:=as.factor(temp),with=F]\n\t\t\t\t},\n\t\t\t\tcontinuous = NULL\t# do nothing\n\t\t)\n\t\tinvisible(NULL)\n\t}\n\t# set the newkey to use in subfunc \"assignCovariateFormat\"\n\tsetkey(factors_annotation_table,colname)\t\n\tsapply(knowledge_driven_factors,assignCovariateFormat_onData_version )\t# no need to return.\n\tsapply(data_driven_factors,assignCovariateFormat_onData_version )\n\tsapply(response_variables,assignCovariateFormat_onData_version )\n\t#-------#\n\t## not useful here, so commented.\n\t# formula_knowledgeOnly <- as.formula(sprintf(\"~%s\",paste(knowledge_driven_factors,collapse=\"+\") ) )\n\t# formula_dataOnly <- as.formula(sprintf(\"~%s\",paste(data_driven_factors,collapse=\"+\") ) )\n\t# formula_unionAll <- as.formula(sprintf(\"~ %s + %s\",paste(knowledge_driven_factors,collapse=\"+\"), paste(data_driven_factors,collapse=\"+\")  ) )\n\t#--------#\n\tformula_unionALLnY <- as.formula( sprintf(\"%s ~ %s + %s\", response_variables ,paste(knowledge_driven_factors,collapse=\"+\"), paste(data_driven_factors,collapse=\"+\")  ) )\n\t\n\t#----match call for 'rfsrc'------#\n\tfunction_index_in_calls <- grep(sprintf(\":%s$\",\"rfsrc\"), names(calls_pm),perl=T )\t# hard match\n\tstopifnot(length(function_index_in_calls) <= 1) # must only have one match or no match for a function within module.\n\t# browser()\n\tif (length(function_index_in_calls)) {\n\t\tresult <- eval.quoted(calls_pm[[function_index_in_calls]])[[1]]\t# need plyr,return a list, extract 1st element.\n\t} else {\t# if no configuration found, use this:\n\t\tresult <- rfsrc(\n\t\tformula = formula_unionALLnY, \n\t\tdata = data, \n\t\tntree=1000, \t# the default value\n\t\tsplit.null = TRUE, # test null hypothesis y has no assocaition with x.\n\t\tna.action = \"na.omit\",\n\t\tnsplit = 5,\t# a maximum of ?nsplit? split points are chosen randomly for each of the ?mtry? variables within a node\n\t\timportance = \"none\",\t# save time, we will do it later using 'vimp' function.\n\t\t# xvar.wt = \t# optional the weight of each variable; a vector.\n\t\tproximity = FALSE,\t# Should the proximity between observations be calculated? very large matrix nxn to store\n\t\tforest = TRUE,\t# store the forest for future prediction of new obs.\n\t\tvar.used = \"all.trees\",\n\t\tsplit.depth = \"all.trees\",\n\t\tseed = -(.seed), # Negative integer specifying seed for the random number generator\n\t\tdo.trace = TRUE\t# trace info,\n\t\t# ntime = ,\t# Integer value which for survival families constrains ensemble calculations to a grid of time values of no more than ntime time points.\n\t\t)\n\n\t}\n\n\t################################################################\n\t#-----plot in batch------#\n\tpdf(sprintf(\"%s_rfsrcObjplot.pdf\",plotNameEssence) )\n\tpar(ps=12,cex=1)\n\tplot.rfsrc(result)\n\tdev.off()\n\t#\n\t# #------plot some individuals---------#\n\t# pdf(sprintf(\"%s_rfsrcSurvObjplot_individualPlot.pdf\",plotNameEssence) )\n\t# par(ps=12,cex=1)\n\t# # plot.rfsrc(result)\n\t# plot.survival(result, subset = c(3,6,9,12,66),haz.model=\"spline\")\n\t# plot.survival(result, subset = c(3,6,9,12,66),haz.model=\"ggamma\")\n\t# # plot.variable(result)\n\t# dev.off()\n\t\n\t#------plot marginal Partial Effect of variables---------# TOO SLOW, can SKIP\n\tif (add_varMarginalEffectPartialPlot) {\n\t\tpdf(sprintf(\"%s_rfsrcObjplot_varMarginalEffectPartialPlot.pdf\",plotNameEssence) )\n\t\tpar(ps=12,cex=1)\n\t\tplot.variable(result,partial=T, npts=5)\n\t\tdev.off()\n\t}\n\t\n\t#------plot various marginal Effect of variables differing in response_variables---------#\n\tpdf(sprintf(\"%s_rfsrcObjplot_varMarginalEffectPlot.pdf\",plotNameEssence) )\n\tpar(ps=12,cex=1)\n\tplot.variable(result)\n\tdev.off()\n\t#\n\t# \n\t#----------------------------------------------------------#\n\t############################################################\n\t\n\t###########################################################\n\t#--------------------var.select---------------------------#\n\t#----match call for 'rfsrc'------#\n\tfunction_index_in_calls <- grep(sprintf(\":%s$\",\"var.select\"), names(calls_pm),perl=T )\t# hard match\n\tstopifnot(length(function_index_in_calls) <= 1) # must only have one match or no match for a function within module.\n\tif (length(function_index_in_calls)) {\n\t\tresult_var_select <- eval.quoted(calls_pm[[function_index_in_calls]])[[1]]\t# need plyr.\n\t} else {\t# if no configuration found, use this:\n\t\tresult_var_select <- var.select(\n\t\t\t\t\tobject = result, \n\t\t\t\t\tmethod = \"md\", \n\t\t\t\t\tconservative = \"medium\",\n\t\t\t\t\tnsplit = 5, # same as above 'rfsrc' function.\n\t\t\t\t\tna.action = \"na.omit\",\n\t\t\t\t\talways.use = knowledge_driven_factors,\t# fix these knowledge_driven_factors\n\t\t\t\t\tdo.trace = TRUE,\t# trace info,\n\t\t\t\t\tverbose = TRUE,\t# verbose info,\n\t\t)\n\t}\n\t# result_var_select$topvars will be printed automatically by function.\n\t#---------------------get the VIMP-----------------------------#\n\t# variable importance.\n\tfunction_index_in_calls <- grep(sprintf(\":%s$\",\"vimp\"), names(calls_pm),perl=T )\t# hard match\n\tstopifnot(length(function_index_in_calls) <= 1) # must only have one match or no match for a function within module.\n\tif (length(function_index_in_calls)) {\n\t\tresult_vimp <- eval.quoted(calls_pm[[function_index_in_calls]])[[1]]\t# need plyr.\n\t} else {\t# if no configuration found, use this:\n\t\tresult_vimp <- vimp(\n\t\t\t\t\tobject = result, \n\t\t\t\t\timportance = \"permute\",\n\t\t\t\t\txvar.names = result_var_select$topvars,\t# need this one to use only a subset of features, otherwise too slow to bear. STILL memory/time consuming, e.g. 60G mem\n\t\t\t\t\tjoint = FALSE,\n\t\t\t\t\tseed = -(.seed),\n\t\t\t\t\tdo.trace = TRUE,\t\t\t\t\n\t\t)\n\t}\n\tprint(result_vimp)\n\t#------plot vimp object and side-effect print---------#\n\tpdf(sprintf(\"%s_rfsrcObjplot_vimp.pdf\",plotNameEssence) )\n\tpar(ps=12,cex=1)\n\tplot.rfsrc(result_vimp)\n\tdev.off()\n\t\n\treturn( structure(list(result = result, coefs_selected = result_var_select$topvars, result_var_select = result_var_select, result_vimp = result_vimp ),class= c(\"rfsrcObj\",\"list\")) )\n\t# result and coefs_selected are necessary\n}\t\n\n\n# Browse[2]> result\n                         # Sample size: 63093\n                    # Number of deaths: 2774\n                     # Number of trees: 1000\n          # Minimum terminal node size: 3\n       # Average no. of terminal nodes: 4106.309\n# No. of variables tried at each split: 22\n              # Total no. of variables: 455\n                            # Analysis: RSF\n                              # Family: surv\n                      # Splitting rule: logrank *random*\n       # Number of random split points: 5\n                          # Error rate: 51.13%\n\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  \n#======================================================================#\n# some evidence about model specification regarding factors.\n# data(pbc, package = \"randomForestSRC\")\n# pbc$random_category <- sample(10,nrow(pbc),replace=T)\n# # pbc$random_category  <- as.factor(pbc$random_category )\n# sapply(pbc,class)\n# pbc$stage <- as.factor(pbc$stage)\n# pbc.obj <- rfsrc(Surv(days, status) ~ ., pbc, nsplit = 10)\n# # pbc.obj <- rfsrc(Surv(days, status) ~ days + status + age + treatment + sex + ascites + hepatom + spiders + edema + bili + as.factor(random_category), pbc, nsplit = 10)\n\n# pdf()\n# plot.variable(pbc.obj)\n# dev.off()\t\t\n# > pdf(\"marginalEffect.pdf\")\n# > plot.variable(pbc.obj)\n# Warning message:\n# In bxp(list(stats = c(0.616921280550937, 5.57784999729378, 19.3937990099956,  :\n  # some notches went outside hinges ('box'): maybe set notch=FALSE\n# > dev.off()\n# plot.variable(pbc.obj,partial=T,smooth=T)\n# dev.off()\n# > dev.off()\n\t\t\t\t  ",
    "created" : 1444857706309.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1792854500",
    "id" : "4418411D",
    "lastKnownWriteTime" : 1414810477,
    "path" : "/home/ec2-user/PhilipsHealthcareBDS/PhilipsHealthcareBDS/Module_file/RandomForest.r",
    "project_path" : "Module_file/RandomForest.r",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}